///////////////////////////////////////////////////////////////////////////////////
// The following FIT Protocol software provided may be used with FIT protocol
// devices only and remains the copyrighted property of Garmin International, Inc.
// The software is being provided on an "as-is" basis and as an accommodation,
// and therefore all warranties, representations, or guarantees of any kind
// (whether express, implied or statutory) including, without limitation,
// warranties of merchantability, non-infringement, or fitness for a particular
// purpose, are specifically disclaimed.
//
// Copyright 2022 Garmin International, Inc.
///////////////////////////////////////////////////////////////////////////////////
// ****WARNING****  This file is auto-generated!  Do NOT edit this file.
// Profile Version = 21.89Release
// Tag = production/akw/21.89.00-0-g487f2ed0
///////////////////////////////////////////////////////////////////////////////////


package com.leviatan.fit.repair;

import com.leviatan.fit.BufferedMesgListener;
import com.leviatan.fit.File;
import com.leviatan.fit.FitListener;
import com.leviatan.fit.ActivityMesg;
import com.leviatan.fit.DateTime;
import com.leviatan.fit.DeviceIndex;
import com.leviatan.fit.DeviceInfoMesg;
import com.leviatan.fit.FileIdMesg;
import com.leviatan.fit.FitMessages;
import com.leviatan.fit.LapMesg;
import com.leviatan.fit.Manufacturer;
import com.leviatan.fit.Mesg;
import com.leviatan.fit.MesgListener;
import com.leviatan.fit.MesgNum;
import com.leviatan.fit.MesgSource;
import com.leviatan.fit.RecordMesg;
import com.leviatan.fit.SessionMesg;
import com.leviatan.fit.Sport;
import com.leviatan.fit.SportMesg;
import com.leviatan.fit.SubSport;

import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.Random;
import java.util.List;

public class ActivityRepairFilter implements BufferedMesgListener, MesgSource {
    private final FitListener fitListener = new FitListener();
    private final ArrayList<MesgListener> mesgListeners = new ArrayList<MesgListener>();
    private final ArrayList<Mesg> filteredRecordMesgs = new ArrayList<>();
    private int serialNumber = 0;
    private RecordMesg previousMesg = null;
    private boolean continueFilteringRecordMesgs = true;
    private boolean continueCheckingForFileIdMesg = true;
    private FileIdMesg fileIdMesgFromFile = null;

    public ActivityRepairFilter() {
    }

    @Override
    public void onMesg(Mesg mesg) {
        mesg.removeExpandedFields();

        fitListener.onMesg(mesg);

        if (mesg.getNum() == MesgNum.RECORD) {
            filterIncomingRecordMessages();
        }

        checkForFileIdMesg(mesg);
    }

    @Override
    public void addListener(MesgListener mesgListener) {
        if ((mesgListener != null) && !mesgListeners.contains(mesgListener)) {
            mesgListeners.add(mesgListener);
        }
    }

    public boolean canRepairFile() {
        return filteredRecordMesgs.size() != 0;
    }

    @Override
    public void flushMesgs() {
        if (filteredRecordMesgs.size() == 0) {
            return;
        }

        createSerialNumber();

        FitMessages fitMessages = fitListener.getFitMessages();

        RecordMesg start = (RecordMesg) filteredRecordMesgs.get(0);
        RecordMesg end = (RecordMesg) filteredRecordMesgs.get(filteredRecordMesgs.size() - 1);

        DateTime startTime = start.getTimestamp();

        FileIdMesg fileIdMesg = createFileIdMesg(startTime);

        DeviceInfoMesg deviceInfoMesg = createDeviceIdMesg(fitMessages.getDeviceInfoMesgs(), startTime);

        LapMesg lapMesg = createLapMesg(start, end);

        SessionMesg sessionMesg = createSessionMesg(start, end, fitMessages);

        ActivityMesg activityMesg = createActivityMesg(start, end);

        flushMesg(fileIdMesg);
        flushMesg(deviceInfoMesg);
        flushMesgs(fitMessages.getDeveloperDataIdMesgs());
        flushMesgs(fitMessages.getFieldDescriptionMesgs());
        flushMesgs(filteredRecordMesgs);
        flushMesg(lapMesg);
        flushMesg(sessionMesg);
        flushMesg(activityMesg);
    }

    private void checkForFileIdMesg(Mesg mesg) {
        if (!continueCheckingForFileIdMesg) {
            return;
        }

        if (mesg.getNum() == MesgNum.PAD) {
            return;
        }

        if (mesg.getNum() == MesgNum.FILE_ID) {
            fileIdMesgFromFile = new FileIdMesg(mesg);
        }

        continueCheckingForFileIdMesg = false;
    }

    private void filterIncomingRecordMessages() {
        if (!continueFilteringRecordMesgs) {
            return;
        }

        List<RecordMesg> recordMesgs = fitListener.getFitMessages().getRecordMesgs();
        RecordMesg currentMesg = recordMesgs.get(recordMesgs.size() - 1);

        if (!hasValidTimestamp(currentMesg)) {
            return;
        }

        if (filteredRecordMesgs.size() == 0) {
            filteredRecordMesgs.add(currentMesg);
            previousMesg = currentMesg;
            return;
        }

        if (!isSequential(previousMesg, currentMesg)) {
            return;
        }

        if (!isReasonableSpan(previousMesg, currentMesg)) {
            continueFilteringRecordMesgs = false;
            return;
        }

        filteredRecordMesgs.add(currentMesg);
        previousMesg = currentMesg;
    }

    private void createSerialNumber() {
        Random random = new Random();
        serialNumber = random.nextInt();
    }

    private FileIdMesg createFileIdMesg(DateTime timeCreated) {
        FileIdMesg fileIdMesg = fileIdMesgFromFile;

        if (fileIdMesg == null) {
            fileIdMesg = new FileIdMesg();
            fileIdMesg.setType(File.ACTIVITY);
            fileIdMesg.setProduct(0);
            fileIdMesg.setSerialNumber((long) serialNumber);
        }

        if (fileIdMesg.getManufacturer() == null) {
            fileIdMesg.setManufacturer(Manufacturer.DEVELOPMENT);
        }
        if (fileIdMesg.getTimeCreated() == null) {
            fileIdMesg.setTimeCreated(new DateTime(timeCreated));
        }
        return fileIdMesg;
    }

    private DeviceInfoMesg createDeviceIdMesg(List<DeviceInfoMesg> deviceInfoMesgs, DateTime startTime) {
        DeviceInfoMesg deviceInfoMesg = deviceInfoMesgs.stream()
                .filter(mesg -> mesg.getDeviceIndex() != null)
                .filter(mesg -> mesg.getDeviceIndex() == DeviceIndex.CREATOR)
                .findFirst()
                .orElse(null);

        if (deviceInfoMesg == null) {
            deviceInfoMesg = new DeviceInfoMesg();
            deviceInfoMesg.setDeviceIndex(DeviceIndex.CREATOR);
            deviceInfoMesg.setManufacturer(Manufacturer.DEVELOPMENT);
            deviceInfoMesg.setProduct(0);
            deviceInfoMesg.setProductName("File Activity Repair"); // Max 20 Chars
            deviceInfoMesg.setSerialNumber((long) serialNumber);
            deviceInfoMesg.setSoftwareVersion(1.0f);
            deviceInfoMesg.setTimestamp(new DateTime(startTime));
        }

        if (deviceInfoMesg.getTimestamp() == null) {
            deviceInfoMesg.setTimestamp(new DateTime(startTime));
        }

        return deviceInfoMesg;
    }

    private LapMesg createLapMesg(RecordMesg start, RecordMesg end) {
        LapMesg lapMesg = new LapMesg();
        lapMesg.setMessageIndex(0);
        lapMesg.setStartTime(start.getTimestamp());
        lapMesg.setTimestamp(end.getTimestamp());
        lapMesg.setTotalElapsedTime((float) (end.getTimestamp().getTimestamp() - start.getTimestamp().getTimestamp()));
        lapMesg.setTotalTimerTime((float) (end.getTimestamp().getTimestamp() - start.getTimestamp().getTimestamp()));

        if (end.getDistance() != null) {
            lapMesg.setTotalDistance(end.getDistance());
        }

        return lapMesg;
    }

    SessionMesg createSessionMesg(RecordMesg start, RecordMesg end, FitMessages fitMessages) {
        SessionMesg sessionMesg = new SessionMesg();
        sessionMesg.setMessageIndex(0);
        sessionMesg.setStartTime(start.getTimestamp());
        sessionMesg.setTimestamp(end.getTimestamp());
        sessionMesg.setTotalElapsedTime((float) (end.getTimestamp().getTimestamp() - start.getTimestamp().getTimestamp()));
        sessionMesg.setTotalTimerTime((float) (end.getTimestamp().getTimestamp() - start.getTimestamp().getTimestamp()));
        sessionMesg.setFirstLapIndex(0);
        sessionMesg.setNumLaps(1);

        SportMesg sportMesg = fitMessages.getSportMesgs().stream()
                .filter(mesg -> mesg.getSport() != null)
                .filter(mesg -> mesg.getSubSport() != null)
                .findFirst()
                .orElse(null);
        if (sportMesg != null) {
            sessionMesg.setSport(sportMesg.getSport());
            sessionMesg.setSubSport(sportMesg.getSubSport());
            return sessionMesg;
        }

        LapMesg lapMesg = fitMessages.getLapMesgs().stream()
                .filter(mesg -> mesg.getSport() != null)
                .filter(mesg -> mesg.getSubSport() != null)
                .findFirst()
                .orElse(null);
        if (lapMesg != null) {
            sessionMesg.setSport(lapMesg.getSport());
            sessionMesg.setSubSport(lapMesg.getSubSport());
            return sessionMesg;
        }

        sessionMesg.setSport(Sport.GENERIC);
        sessionMesg.setSubSport(SubSport.GENERIC);
        return sessionMesg;
    }

    private ActivityMesg createActivityMesg(RecordMesg start, RecordMesg end) {
        ActivityMesg activityMesg = new ActivityMesg();
        activityMesg.setTimestamp(end.getTimestamp());
        activityMesg.setNumSessions(1);

        int timezoneOffset = ZonedDateTime.now().getOffset().getTotalSeconds();

        activityMesg.setLocalTimestamp(end.getTimestamp().getTimestamp() + timezoneOffset);
        activityMesg.setTotalTimerTime((float) (end.getTimestamp().getTimestamp() - start.getTimestamp().getTimestamp()));
        return activityMesg;
    }

    private boolean hasValidTimestamp(Mesg mesg) {
        Long timestamp = mesg.getFieldLongValue(253);
        return timestamp != null && timestamp >= DateTime.MIN;
    }

    private boolean isSequential(RecordMesg previousRecordMesg, RecordMesg recordMesg) {
        return (previousRecordMesg.getTimestamp().getTimestamp() <= recordMesg.getTimestamp().getTimestamp());
    }

    private boolean isReasonableSpan(RecordMesg previousRecordMesg, RecordMesg recordMesg) {
        final int TWO_DAYS_IN_SECONDS = 172800;
        return (recordMesg.getTimestamp().getTimestamp() < previousRecordMesg.getTimestamp().getTimestamp() + TWO_DAYS_IN_SECONDS);
    }

    private void flushMesg(Mesg mesg) {
        mesgListeners.forEach(mesgListener -> mesgListener.onMesg(mesg));
    }

    private void flushMesgs(List<? extends Mesg> mesgs) {
        mesgs.forEach(mesg -> flushMesg(mesg));
    }
}


