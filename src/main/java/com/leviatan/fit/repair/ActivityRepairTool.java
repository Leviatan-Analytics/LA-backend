///////////////////////////////////////////////////////////////////////////////////
// The following FIT Protocol software provided may be used with FIT protocol
// devices only and remains the copyrighted property of Garmin International, Inc.
// The software is being provided on an "as-is" basis and as an accommodation,
// and therefore all warranties, representations, or guarantees of any kind
// (whether express, implied or statutory) including, without limitation,
// warranties of merchantability, non-infringement, or fitness for a particular
// purpose, are specifically disclaimed.
//
// Copyright 2022 Garmin International, Inc.
///////////////////////////////////////////////////////////////////////////////////
// ****WARNING****  This file is auto-generated!  Do NOT edit this file.
// Profile Version = 21.89Release
// Tag = production/akw/21.89.00-0-g487f2ed0
///////////////////////////////////////////////////////////////////////////////////


package com.leviatan.fit.repair;

import com.leviatan.fit.FileEncoder;
import com.leviatan.fit.Decode;
import com.leviatan.fit.Fit;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;

public class ActivityRepairTool {
    private final String inputFilePath;
    private final String outputFilePath;
    private FileEncoder fileEncoder = new FileEncoder();
    private FileInputStream inputFileStream = null;

    private ActivityRepairTool() {
        inputFilePath = null;
        outputFilePath = null;
    }

    public ActivityRepairTool(String inputFilePath) {
        this.inputFilePath = inputFilePath;
        outputFilePath = createOutputFilePath();
    }

    public static void main(String args[]) throws IOException {
        if (!validateCommandlineArgs(args)) {
            printUsage();
            return;
        }

        File file = new File(args[0]);
        if (!file.exists()) {
            System.out.println("Input file does not exist: " + args[0]);
            return;
        }
        if (!file.getName().toLowerCase().endsWith(".fit")) {
            System.out.println("Input file is not a .fit file: " + args[0]);
            return;
        }

        ActivityRepairTool activityRepairTool = new ActivityRepairTool(args[0]);
        activityRepairTool.repair();
    }

    private static boolean validateCommandlineArgs(String[] args) {
        return args.length == 1;
    }

    private static void printUsage() {
        System.out.println("Usage: java -jar ActivityRepairTool.jar <filename>");
    }

    public String getOutputFilePath() {
        return outputFilePath;
    }

    public void repair() {

        ActivityRepairFilter activityRepairFilter = new ActivityRepairFilter();

        try {
            inputFileStream = new FileInputStream(inputFilePath);

            Decode decoder = new Decode();
            decoder.addListener(activityRepairFilter);
            decoder.read(inputFileStream);
        }
        catch (Exception e) {
            System.out.println("Error while decoding file. Attempting to repair file...");
        }
        finally {
            closeInputStream();
        }

        if (!activityRepairFilter.canRepairFile()) {
            System.out.println("File can not be repaired.");
            return;
        }

        try {
            File outputFile = new File(outputFilePath);
            outputFile.delete();

            fileEncoder = new FileEncoder(outputFile, Fit.ProtocolVersion.V2_0);

            activityRepairFilter.addListener(fileEncoder);

            activityRepairFilter.flushMesgs();

        }
        catch (Exception e) {
            System.out.println("Error in repair.\n");
        }
        finally {
            closeFileEncoder();

            System.out.println("Repair complete. Repaired .fit file can be found at: " + outputFilePath);
        }
    }

    private String createOutputFilePath() {
        return inputFilePath.substring(0, (inputFilePath.length() - 4))
                + "_repaired.fit";
    }

    private void closeInputStream() {
        try {
            inputFileStream.close();
        }
        catch (IOException e) {
            System.err.println("Error closing Input File Stream.");
        }
    }

    private void closeFileEncoder() {
        try {
            if (fileEncoder != null) {
                fileEncoder.close();
            }
        }
        catch (Exception e) {
            System.err.println("Error closing File Encoder.");
        }
    }
}